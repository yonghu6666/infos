HTML
  标签

小程序 运行环境
  在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS8、iOS9、iOS10；
  在 Android 上，
  旧版本，小程序逻辑层的 javascript 代码运行中 X5 JSCore 中，视图层是由 X5 基于 Mobile Chrome 57 内核来渲染的；
  新版本，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由自研 XWeb 引擎基于 Mobile Chrome 67 内核来渲染的；
  在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium 60 Webview 来渲染的
js 类型判断(?)
  typeof
  instanceof
  Object.prototype.toString.call()
  Object.prototype.isPrototypeOf()
  Object.getPrototype()
  is


js 运算符
  汇总表
    优先级                       运算类型                        关联性                       运算符
    20                          圆括号                           n/a（不相关）                ( ... )
    ----------------------------------------------------------------------------------------------------------
    19                          成员访问                         从左到右                     ... . ...
                                需计算的成员访问                  从左到右                     ... [ ... ]
                                new（带参数列表）                 n/a                         new ... ( ... )
                                函数调用                         从左到右                     ... ( ... )
                                可选链(Optional chaining)        从左到右                     ?.
    ----------------------------------------------------------------------------------------------------------
    18                          new（无参数列表）                 从右到左                     new ...
    ----------------------------------------------------------------------------------------------------------
    17                          后置递增（运算符在后）             n/a                         ... ++
                                后置递减（运算符在后）             n/a                         ... --
    ----------------------------------------------------------------------------------------------------------
    16                          逻辑非                           从右到左                     ! ...
                                按位非                           从右到左                     ~ ...
                                一元加法                         从右到左                     + ...
                                一元减法                         从右到左                     - ...
                                前置递增                         从右到左                     ++ ...
                                前置递减                         从右到左                     -- ...
                                typeof                          从右到左                     typeof ...
                                void                            从右到左                     void ...
                                delete                          从右到左                     delete ...
                                await                           从右到左                     await ...
    ----------------------------------------------------------------------------------------------------------
    15                          幂                              从右到左                     
    ----------------------------------------------------------------------------------------------------------
    14                          乘法                            从左到右
                                除法                            从左到右
                                取模                            从左到右
    ----------------------------------------------------------------------------------------------------------
    13                          加法                            从左到右
                                减法                            从左到右
    ----------------------------------------------------------------------------------------------------------
    12                          按位左移                         从左到右
                                按位右移                         从左到右
                                无符号右移                       从左到右
    ----------------------------------------------------------------------------------------------------------
    11                          小于                             从左到右
                                小于等于                         从左到右
                                大于                             从左到右
                                大于等于                         从左到右
                                in                              从左到右
                                instanceof                      从左到右
    ----------------------------------------------------------------------------------------------------------
    10                          等号                             从左到右
                                非等号                           从左到右
                                全等号                           从左到右
                                非全等号                         从左到右
    ----------------------------------------------------------------------------------------------------------
    9                           按位与                           从左到右
    ----------------------------------------------------------------------------------------------------------
    8                           按位异或                         从左到右
    ----------------------------------------------------------------------------------------------------------
    7                           按位或                           从左到右
    ----------------------------------------------------------------------------------------------------------
    6                           逻辑与                           从左到右
    ----------------------------------------------------------------------------------------------------------
    5                           逻辑或                           从左到右
    ----------------------------------------------------------------------------------------------------------
    4                           条件运算符                       从右到左
    ----------------------------------------------------------------------------------------------------------
    3                           赋值                             从右到左
    ----------------------------------------------------------------------------------------------------------
    2                           yield                            从右到左
                                yield*                           从右到左
    ----------------------------------------------------------------------------------------------------------
    1                           展开运算符                        n/a
    ----------------------------------------------------------------------------------------------------------
    0                           逗号                             从左到右

js this(?)

js 闭包
  函数对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包(closure)。也就是说，闭包可以让你从内部函数访问外部函数作用域。在JavaScript中，每当函数被创建，就会在函数生成时生成闭包。
  词法作用域
  
  闭包
    闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。
js 函数
  函数声明（函数语句）
    function name([param[, param[, ... param]]]) {statements}
    一个函数最多有255个参数
  函数表达式(function expression)
    var myFunction = function name([param[, param[, ... param]]]) {statements}
    name
      函数名，可以省略，当省略函数名时，该函数就成为了匿名函数。
    函数表达式不会提升，所以不能再定义之前调用。一个函数最多有255个参数。
    当函数只使用一次时，通常使用IIFE(Immediately Invokable Function Expressions)，即立即执行函数。IIFE是在函数声明后立即调用的函数表达式。
  函数生成器声明（function*语句）(?)
    function* name([param[, param[, ...param]]]) {statements}
    函数声明的特殊语法
  函数生成器表达式（function*表达式）(?)
    function* [name]([param] [, param] [..., param]) {statements}
    构造函数表达式和函数声明类似，并且有着相同的语法
  箭头函数表达式(=>)
    ([param][,param]) => {statements}
    param => expression
    param
      参数名称。零参数需要用()表示，只有一个参数时不需要括号（如foo => 1）。
    statements or expression
      多个声明statements需要用大括号括起来，而单个表达式则不需要。表达式expression也是该函数的隐式返回值。
  Function构造函数
    new Function (arg1, arg2, ... argN, functionBody)
    arg1, arg2, ... argN
      函数使用零个或多个名称作为正式的函数名称。每一个必须是一个符合有效的JavaScript标志符规则的字符串，或用逗号分隔的字符串列表，如"x", "the Value"或"a, b"。
    functionBody
      一个构成函数定义的，包含JavaScript声明语句的字符串。
    如new Function('x', 'y', 'return x * y');
    不推荐使用Function构造函数创建函数，因为它需要的函数体作为字符串可能会阻止一些JS引擎优化，也会引起其他问题。(?)
  生成器函数的构造函数
    new GeneratorFunction (arg1, arg2, ... argN, functionBody)
    不推荐使用构造器函数的构造函数创建函数，因为它需要的函数体作为字符串可能会阻止一些JS引擎优化，也会引起其他问题。(?)

  函数名不能被改变，但函数的变量却能够被再分配。函数名只能在函数体内使用。倘若在函数体外使用函数名，将会导致错误（如果函数之前是通过一个var语句声明的则是undefined）。
  可以使用typeof操作符检测一个函数是否存在。

浏览器 iframe内存回收
  回收方法：
    清理iframe
    PC
      chrome
        需要清理父窗口中，引用了iframe内部的引用数据类型的变量
        不需要清理iframe内部创建的引用数据类型的变量
        不需要清理iframe内部对闭包中暴露出的函数的引用
        不需要清理iframe内部引用的父窗口的变量
      firefox
        需要清理父窗口中，引用了iframe内部的引用数据类型的变量
        需要清理内部创建的引用数据类型的变量
        需要清理对闭包中暴露出的函数的引用
        不需要清理iframe内部引用的父窗口的变量
      Opera
        需要清理父窗口中，引用了iframe内部的引用数据类型的变量
        不需要清理iframe内部创建的引用数据类型的变量
        不需要清理iframe内部对闭包中暴露出的函数的引用
        不需要清理iframe内部引用的父窗口的变量

      Safari
        暂未整理
  Mobile
    先在PC端解决iframe内存释放问题，然后再在手机端查看，是否存在相应的问题。
    以下以打开、关闭20次iframe操作为样本，查看手机内存变化
    chrome
      根据样本操作之后的内存表现，规则同其PC浏览器
    firefox
      根据样本操作之后的内存表现，规则同其PC浏览器
    opera
      根据样本操作之后的内存表现，规则同其PC浏览器
    Xiaomi
      根据样本操作之后的内存表现，规则同其PC浏览器
    Safari on iOS

    AndroidWebView

    WKWebview

浏览器 内核
  渲染引擎
    Blink
      Google Chrome，Edge，Opera
    Webkit
      Safari
    Gecko
      Firefox
    Trident
      IE，360，搜狗等
  JS引擎
    V8
      Chrome
    Nitro(JavaScriptCore)
      Safari
    TraceMonkey
      Firefox
    Chakra
      Edge
浏览器 Tasks and Microtasks
  Tasks execute in order, and the browser may render between them.
  Microtasks execute in order, and are executed:
    1.after every callback, as long as no other JavaScript is mid_execution.
    2.at the end of each task.


adb 
  adb -s yourdeviceId install yourapp
  adb -s yourdeviceId uninstall yourappId

react
  life-cycle functions
    static getDerivedStateFromProps(props, state);
      在组件实例化之后以及重新渲染之前调用。

    getSnapshotBeforeUpdate(prevProps, prevState);
      在更新之前（如：更新DOM之前）被调用。

  ant design pro数据流转：
    View层dispatch操作action –> 
    触发models层effect中相应方法 –> 
    触发call发起services层请求，获取接口数据 –> 
    触发put发起reducer处理相应的action更新数据 –> 
    更新model层中state –> 
    触发view层的render方法进行重新渲染 –> 
    页面更新



react native
  npm cache clean --force
  react-native start
    启动调试服务器

  react-native run-android
    react-native run-android --deviceId yourdeviceId
    adb reverse tcp:8081 tcp:8081
      adb -s 8fdb0742 reverse tcp:8081 tcp:8081
      adb -s emulator-5554 reverse tcp:8081 tcp:8081
  release版本
    cd android
    gradlew clean
    gradlew assembleRelease
  navigation
    this.props.navigation.navigate('GamePane', {
                  webType: 1, 
                  webURL: this.appRuleURL,
              });
    this.props.navigation.state.params.webType;
    
    react-native run-android --deviceId 8fdb0742
    react-native run-android --deviceId emulator-5554
  添加包
    1) react-native-fs  
      npm install react-native-fs --save
    2) native-base
      npm install native-base --save
    3) react-navigation
      npm install react-navigation --save
    4) 拷贝
      拷贝文件夹./node_modules/native-base/src/theme到./app/plugins下，并改名为native-base_theme
    5) react-native-i18n
      npm install react-native-i18n --save
      react-native link react-native-i18n
    5) react-native-fbsdk
      npm install react-naitve-fbsdk --save
      react-native link react-naitve-fbsdk
    6) react-native-fbads
      npm install react-naitve-fbads --save
      react-native link react-naitve-fbads
    7) react-native-swiper
      npm install react-native-swiper --save
    8) react-native-root-toast
      npm install react-native-root-toast --save

    npm uninstall react-native-whc-toast --save
    
    
    npm install xxx --save
    react-native link xxx
    react-native unlink xxx
    npm uninstall --save xxx
    
  FB等第三方登录，需要获取的信息
    userID(134116137729302)、lastRefreshtime、expirationTime、accessToken、userImgURL
    
    获取头像
      https://graph.facebook.com/134116137729302/picture
      https://graph.facebook.com/134116137729302/picture?type=large
    获取name
      https://graph.facebook.com/me?access_token=
      https://graph.facebook.com/me?fields=email,name,friends&access_token=
  project problems
    1)React-Native Error: Unable to resolve module `./index` from `\node_modules\react-native\scripts/.`
      open node_modules\react-native\scripts\launchPackager.bat
      // delete this line
      node "%~dp0..\cli.js" start 
      Add this line
      node "%~dp0..\cli.js" start --projectRoot ../../../
    
    2)thinkjs memory leak
    (node:68000) 
    
      this.setMaxListeners(30);
    D:\workspace\Web\hellcase\CmsWing\node_modules\think-websocket-ws\index.js L82
  icon 不显示图标
    close running packager
    run react-native link react-native-vector-icons
    run react-native start --reset-cache
    Finally use react-native run-android

  生成release包的方法
    进入项目根目录下的android目录，执行命令：
      react-native bundle --entry-file index.js --platform android --dev false --bundle-output ./bundles/android/index.android.bundle --assets-dest ./bundles/android
  Unable to resolve module `./index` from `\node_modules\react-native\scripts/.`
    Update node_modules\react-native\scripts\launchPackager.bat file.
      @echo off
      title Metro Bundler
      call .packager.bat

      :: delete this line
      node "%~dp0..\cli.js" start 

      :: Add this line
      node "%~dp0..\cli.js" start --projectRoot ../../../ 

      pause
      exit
    We are giving project root path to Metro instance here

  react-native-vector-icons自定义图标
    9.1 把iconfont.css放入\react-native-vector-icons\Fonts
    9.2 react-native-vector-icons\glyphmaps中加入iconfont.json
    9.3 \react-native-vector-icons中加入iconfont.js
    9.4 在需要使用的地方，添加代码:
      import MyIcons from 'react-native-vector-icons/iconfont';
      ...
      <MyIcons name='duihuan' size={26} color='#cccccc'/> 
  Questions
    1.ReferenceError: ReferenceError: React is not defined
      使用Component组件时，需要同时引入React组件
      import React, { Component } from "react";
  使用props做数据流动时，可以把当前组件的state传递下去。这样，当前组件的state变化后，子组件也可以获取变化后的state数据。
    Question：
      在子组件的render中获取其自身的state后，如果父组件的state变化，会重新渲染子组件吗
  RN 缺点
    1.布局
      RN的css语法，是CSS标准语法的一个子集。
    2.限制
      不支持Android九点切图。
V8
  GC主要做三件事：
    1.区分活着的、死亡的对象；
    2.重新利用死亡对象占用的内存；
    3.压紧、去分片内存。

nunjucks
  {##}，会注释其中包含的nunjucks代码和h5代码
  <!-- -->只能注释其中的h5代码，而其中的nunjucks代码会执行

h5
  游戏全屏按钮
  Laya框架是支持全屏功能的，但是存在一些限制，如不支持Firefox浏览器的全屏功能。所以考虑用原生H5来实现。
  思路比较简单：在游戏UI的上层，添加按钮。按钮添加事件，实现全屏、退出全屏功能。
  遇到的问题：
    添加按钮之后，向下拖动按钮时，会触发浏览器的下拉刷新事件。解决办法：在按钮的样式里添加
    overscroll-behavior: none;，并在拖动事件里添加evt.preventDefault();，阻止事件在冒泡阶段向外传递。
JQuery
  jquery
  $(#id)，#取的是id
  $(.class)，.取的是class
  $(:inputtype)，:取的是所有的input，其type为‘inputtype’类型

CSS
  水平居中的方法
    行内元素（display: inline）
      设置text-align: center;实现
    定宽块状元素（display: block）
      设置左右margin的值为auto实现：margin: 0 auto;实现
    不定宽块状元素
      1)改变块状元素的display属性为inline，并给父级设置text-align: center来实现
        <div style="text-align: center;">
          <div style="display: inline;">不定宽元素的水平居中</div>
        </div>
      2)利用绝对定位，让元素向右偏移50%，并向左偏移自身的50%
        <div style="position: absolute; left: 50%; transform: translateX(-50%);">不定宽元素的水平居中</div>
      3)利用flex实现水平居中
        <div style="display: flex;">
          <div style="margin: 20px auto;">不定宽元素的水平居中</div>
        </div>
        <div style="width: fit-content; margin-left: auto; margin-right: auto;">不定宽元素的水平居中</div>

  引入的非同源的服务器端的CSS文件，background里使用非同源的服务器端的资源时，显示异常。
  选择器
    ' ' 后代选择器，所包含的所有层级的元素，都会被选择
    '>' 子选择器（不能有层级间隔，即只能选择所包含的第一层的元素，第二层及更深的层级不能被选择）
    '~' 兄弟选择器，选择位于其后面的元素，且具有相同的父元素
    '+' 相邻兄弟选择器，只选择紧接在后面的元素，且而二者具有相同的父元素
  position
    absolute 生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。
    fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。
    relative 生成相对的元素，相对于其正常位置进行定位。
postMessage
  它可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面具有相同的协议、端口号、以及主机(两个页面的模数Document.domain设置相同的值)时，这两个脚本才能相互通信。
  otherWindow.postMessage(message, tarOrigin, [transfer])
    otherWindow，其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。
    message，将要发送到其他window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。
    targetOrigin，通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。
    transfer 可选。是一串和message 同时传递的 Transferable 对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。
Cookie
  会话Cookie，浏览器关闭之后自动删除。
  持久Cookie，仅在达到过期时间后被删除。
  设置HttpOnly的Cookie，无法通过js获取，仅能发送给服务端。
  作用域
    Domain、Path标识了Cookie的作用域。
    Domain标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（不包括子域名）。如果制定了Domain，则一般包含子域名。如，设置Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。
    Path标识指定了主机下的哪些路径可以接收Cookie（该URL路径必须存在于请求URL中）。以字符%x2F("/")作为路径分隔符，子路径也会被匹配。如设置Path=/docs，则以下路径都会被匹配：/docs、/docs/Web/、/docs/Web/HTTP。
CORS
  跨域资源共享
  浏览器会限制发起跨站请求，或者是跨站请求被正常发起，但返回结果被浏览器拦截。
  该机制允许web应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。
  跨域资源共享(cross-origin sharing standard)允许在下列场景中使用跨域htpp请求：
    1.由XMLHttpRequest或Fetch发起的跨域HTTP请求。
    2.Web字体(CSS中通过@font-face使用跨域字体资源)，因此网站就可以发布TrueType字体资源，并只允许已授权网站进行跨站调用。
    3.WebGL贴图。
    4.使用drawImage将Image/video画面绘制到Canvas。
  跨域资源共享新增了一组http首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的http请求方法(特别是get以外的http请求，或者搭配某些mime类型的post请求)，浏览器必须首先使用options方法发起一个预检请求(preflight request)，从而获知服务器是否允许该跨域请求。服务器确认允许之后，才发起实际的http请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证(包括Cookies和http认证相关数据)。
CSRF
  cross-site request forgery，跨站请求伪造，也被称为one click attack/session riding，缩写为CSRF/XSRF。
  例子：
    登录了网站http://www.mybank.com，并可以通过http://www.mybank.comTransfer.php?toBankId=xx&money=xxx的方式转账
    此时便可以通过欺骗方式进行转账操作，如<img src=http://www.mybank.com/Transfer.php?toBankId=11&money=1000>
  防御策略
    验证HTTP Referer字段
      根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。服务端可以根据请求中的Referer值判断，是否是当前网站发来的请求。
    在请求地址中添加token并验证
      黑客很难伪造token，并且token不存储于cookie中，这样就避免了cookie被盗用的风险。
    在HTTP头中自定义属性并验证
      把token放入HTTP头中自定义的属性。通过XMLHttpRequest这个类，可以一次性给所有该类请求添加token这个HTTP头属性，并把token值放入其中。
Token
  Refresh Token
    用户登录之后，服务端会返回两个token：Access Token、Refresh Token。Access Token的有效期较短，Refresh Token的有效期较长。在Access Token失效后，客户端通过Refresh Token获取新的Access Token和Refresh Token，如果Refresh Token也失效了，则只能重登录。
XSS
  Cross-site scripting，跨域脚本攻击。

跨域请求方案
  协议、域名、端口相同时，被认为是同源。跨域的http请求，在发起时被浏览器限制，或是在响应返回时，会被浏览器拦截。这被称为同源策略。
  JSONP
    DOM元素的src属性，能够绕过同源策略。这类元素包括：img、link、script、iframe等。JSONP就是使用script元素实现的。
    实现流程：web端声明一个回调函数，创建一个script元素，将回调函数的名称作为url的参数，赋值给script元素的src属性。服务端收到请求后，把收到的函数名和客户端需要的数据拼接成一个字符串，通过http协议传递给web端。
  CORS
    仅仅依靠web端，是不能实现CORS的。它需要服务端设置Access-Control-Allow-Origin，该参数表示哪些域名可以访问当前服务器的资源。
  nginx
    反向代理
  postMessage
    
  websocket